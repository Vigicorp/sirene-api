<?php
/**
 * UniteLegaleApi
 * PHP version 5
 *
 * @category Class
 * @package  Sirene\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API Sirene
 *
 * <p>Date de la dernière modification : 31 janvier 2019</p> <p>API Sirene donne accès aux informations concernant les entreprises et les établissements immatriculés au répertoire interadministratif Sirene depuis sa création en 1973, y compris les unités fermées. La recherche peut être unitaire, multicritère, phonétique et porter sur les données courantes et historisées. Les services actuellement disponibles interrogent les unités légales (Siren) et les établissements (Siret). À venir : prédécesseurs et successeurs d'un établissement et données pluriannuelles. <h4 class=\"add-margin-top-5x\">Licence</h4> <p>La réutilisation des jeux de données mis à votre disposition à partir de la base Sirene est soumise à la licence « <a href=\"https://www.etalab.gouv.fr/licence-ouverte-open-licence\" target=\"_blank\">Licence Ouverte / Open Licence version 2.0</a> » conçue par Etalab, organisme chargé de coordonner l’action des services de l’État et de ses établissements publics pour faciliter la réutilisation la plus large possible de leurs informations publiques, via le portail interministériel <a href=\"https://www.data.gouv.fr/fr/datasets/base-sirene-des-entreprises-et-de-leurs-etablissements-siren-siret/\" title=\"data.gouv.fr\" target=\"_blank\" class=\"external-link\">data.gouv.fr</a></p> <p>La base Sirene contenant des données à caractère personnel, l’Insee attire votre attention sur les obligations légales qui en découlent :</p> <ul> <li>Le traitement de ces données relève des obligations de déclaration de la Loi 78-17 du 6 janvier 1978 modifiée, dite Loi Informatique et Libertés : <a href=\"http://www.legifrance.gouv.fr/affichTexte.do?cidTexte=JORFTEXT000000886460\" title=\"Nouvelle fenêtre : la loi 78-17 du 6 janvier 1978 sur legifrance.gouv.fr\" target=\"_blank\" class=\"external-link\">Loi 78-17</a></li> <li>Selon votre usage du jeu de données, il est de votre responsabilité de tenir compte du statut de diffusion le plus récent de chaque personne physique.</li> </ul> <p>En effet, selon l’<a href=\"http://www.legifrance.gouv.fr/affichCodeArticle.do;jsessionid=C505A51DBC1A4EB1FFF3764C69ACDB1C.tpdjo11v_1?idArticle=LEGIARTI000020165030&cidTexte=LEGITEXT000005634379&dateTexte=20100702\" title=\"Nouvelle fenêtre : l’article A123-96 du code de commerce sur legifrance.gouv.fr\" target=\"_blank\" class=\"external-link\">Article A123-96 du code de commerce</a> :</p> <p>\"Toute personne physique peut demander soit directement lors de ses formalités de création ou de modification, soit par lettre adressée au directeur général de l’Institut national de la statistique et des études économiques, que les informations du répertoire la concernant ne puissent être utilisées par des tiers autres que les organismes habilités au titre de l’<a href=\"https://www.legifrance.gouv.fr/affichCodeArticle.do?cidTexte=LEGITEXT000005634379&idArticle=LEGIARTI000006258837&dateTexte=&categorieLien=cid\" title=\"article R. 123-224\" target=\"_blank\" class=\"external-link\">article R. 123-224</a> ou les administrations, à des fins de prospection, notamment commerciale.\"</p> <h4 class=\"add-margin-top-5x\">Limites d'utilisation</h4> <p>L'usage d'API Sirene est soumis à une limite de 30 interrogations par minute.</p> <p>L'Insee se réserve le droit de changer cette limite en cas de nécessité.</p> <h4 class=\"add-margin-top-5x\">Droit de rectification des données du répertoire Sirene</h4> <p>L'<a href=\"https://www.legifrance.gouv.fr/affichCodeArticle.do?idArticle=LEGIARTI000020165042&cidTexte=LEGITEXT000005634379&dateTexte=20151223\" title=\"Nouvelle fenêtre : l’article A123-90 du code de commerce sur legifrance.gouv.fr\" target=\"_blank\" class=\"external-link\">article A123-90 du code de commerce</a> indique que \"Le droit d'accès prévu par l'article 39 de la loi du 6 janvier 1978 s'exerce auprès du directeur régional de l'Institut national de la statistique et des études économiques.\"</p> <h4 class=\"add-margin-top-5x\">Homologation provisoire RGS (Référentiel général de sécurité)</h4> <p>Le directeur général de l’Insee, après avoir recueilli l’avis des membres de la commission d’homologation de sécurité, atteste que le système \"API Sirene\" est protégé, conformément aux objectifs fixés par le maître d’ouvrage, pour répondre, de manière proportionnée, aux besoins de protection du système et des informations, face aux risques identifiés.</p> <p>Paris le 22 Juin 2018</p> <p>Pour le directeur général de l’Insee</p> <p>Par délégation</p> <p>Le secrétaire général de l’Insee</p>
 *
 * OpenAPI spec version: 3.6.3
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.5
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Sirene\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Sirene\Client\ApiException;
use Sirene\Client\Configuration;
use Sirene\Client\HeaderSelector;
use Sirene\Client\ObjectSerializer;

/**
 * UniteLegaleApi Class Doc Comment
 *
 * @category Class
 * @package  Sirene\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class UniteLegaleApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation findBySiren
     *
     * Recherche d'une unité légale par son numéro Siren (9 chiffres)
     *
     * @param  string $siren Identifiant de l&#39;unité légale (9 chiffres) (required)
     * @param  string $date Date à laquelle on veut obtenir les valeurs des données historisées (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     *
     * @throws \Sirene\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sirene\Client\Model\ReponseUniteLegale
     */
    public function findBySiren($siren, $date = null, $champs = null, $masquer_valeurs_nulles = null)
    {
        list($response) = $this->findBySirenWithHttpInfo($siren, $date, $champs, $masquer_valeurs_nulles);
        return $response;
    }

    /**
     * Operation findBySirenWithHttpInfo
     *
     * Recherche d'une unité légale par son numéro Siren (9 chiffres)
     *
     * @param  string $siren Identifiant de l&#39;unité légale (9 chiffres) (required)
     * @param  string $date Date à laquelle on veut obtenir les valeurs des données historisées (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     *
     * @throws \Sirene\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sirene\Client\Model\ReponseUniteLegale, HTTP status code, HTTP response headers (array of strings)
     */
    public function findBySirenWithHttpInfo($siren, $date = null, $champs = null, $masquer_valeurs_nulles = null)
    {
        $returnType = '\Sirene\Client\Model\ReponseUniteLegale';
        $request = $this->findBySirenRequest($siren, $date, $champs, $masquer_valeurs_nulles);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sirene\Client\Model\ReponseUniteLegale',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findBySirenAsync
     *
     * Recherche d'une unité légale par son numéro Siren (9 chiffres)
     *
     * @param  string $siren Identifiant de l&#39;unité légale (9 chiffres) (required)
     * @param  string $date Date à laquelle on veut obtenir les valeurs des données historisées (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findBySirenAsync($siren, $date = null, $champs = null, $masquer_valeurs_nulles = null)
    {
        return $this->findBySirenAsyncWithHttpInfo($siren, $date, $champs, $masquer_valeurs_nulles)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findBySirenAsyncWithHttpInfo
     *
     * Recherche d'une unité légale par son numéro Siren (9 chiffres)
     *
     * @param  string $siren Identifiant de l&#39;unité légale (9 chiffres) (required)
     * @param  string $date Date à laquelle on veut obtenir les valeurs des données historisées (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findBySirenAsyncWithHttpInfo($siren, $date = null, $champs = null, $masquer_valeurs_nulles = null)
    {
        $returnType = '\Sirene\Client\Model\ReponseUniteLegale';
        $request = $this->findBySirenRequest($siren, $date, $champs, $masquer_valeurs_nulles);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findBySiren'
     *
     * @param  string $siren Identifiant de l&#39;unité légale (9 chiffres) (required)
     * @param  string $date Date à laquelle on veut obtenir les valeurs des données historisées (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findBySirenRequest($siren, $date = null, $champs = null, $masquer_valeurs_nulles = null)
    {
        // verify the required parameter 'siren' is set
        if ($siren === null || (is_array($siren) && count($siren) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $siren when calling findBySiren'
            );
        }

        $resourcePath = '/siren/{siren}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($champs !== null) {
            $queryParams['champs'] = ObjectSerializer::toQueryValue($champs);
        }
        // query params
        if ($masquer_valeurs_nulles !== null) {
            $queryParams['masquerValeursNulles'] = ObjectSerializer::toQueryValue($masquer_valeurs_nulles);
        }

        // path params
        if ($siren !== null) {
            $resourcePath = str_replace(
                '{' . 'siren' . '}',
                ObjectSerializer::toPathValue($siren),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findSirenByQ
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \Sirene\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sirene\Client\Model\ReponseUnitesLegales
     */
    public function findSirenByQ($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        list($response) = $this->findSirenByQWithHttpInfo($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur);
        return $response;
    }

    /**
     * Operation findSirenByQWithHttpInfo
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \Sirene\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sirene\Client\Model\ReponseUnitesLegales, HTTP status code, HTTP response headers (array of strings)
     */
    public function findSirenByQWithHttpInfo($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        $returnType = '\Sirene\Client\Model\ReponseUnitesLegales';
        $request = $this->findSirenByQRequest($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sirene\Client\Model\ReponseUnitesLegales',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findSirenByQAsync
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSirenByQAsync($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        return $this->findSirenByQAsyncWithHttpInfo($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findSirenByQAsyncWithHttpInfo
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSirenByQAsyncWithHttpInfo($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        $returnType = '\Sirene\Client\Model\ReponseUnitesLegales';
        $request = $this->findSirenByQRequest($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findSirenByQ'
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findSirenByQRequest($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        if ($nombre !== null && $nombre > 100000) {
            throw new \InvalidArgumentException('invalid value for "$nombre" when calling UniteLegaleApi.findSirenByQ, must be smaller than or equal to 100000.');
        }
        if ($nombre !== null && $nombre < 0) {
            throw new \InvalidArgumentException('invalid value for "$nombre" when calling UniteLegaleApi.findSirenByQ, must be bigger than or equal to 0.');
        }

        if ($debut !== null && $debut > 1000000) {
            throw new \InvalidArgumentException('invalid value for "$debut" when calling UniteLegaleApi.findSirenByQ, must be smaller than or equal to 1000000.');
        }
        if ($debut !== null && $debut < 0) {
            throw new \InvalidArgumentException('invalid value for "$debut" when calling UniteLegaleApi.findSirenByQ, must be bigger than or equal to 0.');
        }


        $resourcePath = '/siren';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date);
        }
        // query params
        if ($champs !== null) {
            $queryParams['champs'] = ObjectSerializer::toQueryValue($champs);
        }
        // query params
        if ($masquer_valeurs_nulles !== null) {
            $queryParams['masquerValeursNulles'] = ObjectSerializer::toQueryValue($masquer_valeurs_nulles);
        }
        // query params
        if ($facette_champ !== null) {
            $queryParams['facette.champ'] = ObjectSerializer::toQueryValue($facette_champ);
        }
        // query params
        if ($tri !== null) {
            $queryParams['tri'] = ObjectSerializer::toQueryValue($tri);
        }
        // query params
        if ($nombre !== null) {
            $queryParams['nombre'] = ObjectSerializer::toQueryValue($nombre);
        }
        // query params
        if ($debut !== null) {
            $queryParams['debut'] = ObjectSerializer::toQueryValue($debut);
        }
        // query params
        if ($curseur !== null) {
            $queryParams['curseur'] = ObjectSerializer::toQueryValue($curseur);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/csv'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findSirenByQPost
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \Sirene\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Sirene\Client\Model\ReponseUnitesLegales
     */
    public function findSirenByQPost($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        list($response) = $this->findSirenByQPostWithHttpInfo($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur);
        return $response;
    }

    /**
     * Operation findSirenByQPostWithHttpInfo
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \Sirene\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Sirene\Client\Model\ReponseUnitesLegales, HTTP status code, HTTP response headers (array of strings)
     */
    public function findSirenByQPostWithHttpInfo($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        $returnType = '\Sirene\Client\Model\ReponseUnitesLegales';
        $request = $this->findSirenByQPostRequest($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Sirene\Client\Model\ReponseUnitesLegales',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findSirenByQPostAsync
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSirenByQPostAsync($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        return $this->findSirenByQPostAsyncWithHttpInfo($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findSirenByQPostAsyncWithHttpInfo
     *
     * Recherche multicritère d'unités légales
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSirenByQPostAsyncWithHttpInfo($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        $returnType = '\Sirene\Client\Model\ReponseUnitesLegales';
        $request = $this->findSirenByQPostRequest($q, $date, $champs, $masquer_valeurs_nulles, $facette_champ, $tri, $nombre, $debut, $curseur);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findSirenByQPost'
     *
     * @param  string $q Contenu de la requête multicritères, voir la documentation pour plus de précisions (optional)
     * @param  string $date Date à laquelle s&#39;appliqueront les critères de recherche sur les champs historisés, format AAAA-MM-JJ (optional)
     * @param  string $champs Liste des champs demandés, séparés par des virgules (optional)
     * @param  bool $masquer_valeurs_nulles Masque (true) ou affiche (false, par défaut) les attributs qui n&#39;ont pas de valeur (optional)
     * @param  string $facette_champ Liste des champs sur lesquels des comptages seront effectués, séparés par des virgules (optional)
     * @param  bool $tri Active ou non le tri des résultats par identifiants (optional)
     * @param  int $nombre Nombre d&#39;éléments demandés dans la réponse, défaut 20 (optional)
     * @param  int $debut Rang du premier élément demandé dans la réponse, défaut 0 (optional)
     * @param  string $curseur Paramètre utilisé pour la pagination profonde, voir la documentation pour plus de précisions (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findSirenByQPostRequest($q = null, $date = null, $champs = null, $masquer_valeurs_nulles = null, $facette_champ = null, $tri = null, $nombre = null, $debut = null, $curseur = null)
    {
        if ($nombre !== null && $nombre > 100000) {
            throw new \InvalidArgumentException('invalid value for "$nombre" when calling UniteLegaleApi.findSirenByQPost, must be smaller than or equal to 100000.');
        }
        if ($nombre !== null && $nombre < 0) {
            throw new \InvalidArgumentException('invalid value for "$nombre" when calling UniteLegaleApi.findSirenByQPost, must be bigger than or equal to 0.');
        }

        if ($debut !== null && $debut > 1000000) {
            throw new \InvalidArgumentException('invalid value for "$debut" when calling UniteLegaleApi.findSirenByQPost, must be smaller than or equal to 1000000.');
        }
        if ($debut !== null && $debut < 0) {
            throw new \InvalidArgumentException('invalid value for "$debut" when calling UniteLegaleApi.findSirenByQPost, must be bigger than or equal to 0.');
        }


        $resourcePath = '/siren';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // form params
        if ($q !== null) {
            $formParams['q'] = ObjectSerializer::toFormValue($q);
        }
        // form params
        if ($date !== null) {
            $formParams['date'] = ObjectSerializer::toFormValue($date);
        }
        // form params
        if ($champs !== null) {
            $formParams['champs'] = ObjectSerializer::toFormValue($champs);
        }
        // form params
        if ($masquer_valeurs_nulles !== null) {
            $formParams['masquerValeursNulles'] = ObjectSerializer::toFormValue($masquer_valeurs_nulles);
        }
        // form params
        if ($facette_champ !== null) {
            $formParams['facette.champ'] = ObjectSerializer::toFormValue($facette_champ);
        }
        // form params
        if ($tri !== null) {
            $formParams['tri'] = ObjectSerializer::toFormValue($tri);
        }
        // form params
        if ($nombre !== null) {
            $formParams['nombre'] = ObjectSerializer::toFormValue($nombre);
        }
        // form params
        if ($debut !== null) {
            $formParams['debut'] = ObjectSerializer::toFormValue($debut);
        }
        // form params
        if ($curseur !== null) {
            $formParams['curseur'] = ObjectSerializer::toFormValue($curseur);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/csv'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
